/**
 * @name MCPlayers
 * @version 0.1.3
 * @author Pi
 * @description shows the player list for supported servers (make a pr to add your own)
 * @website https://github.com/pipipear/BD
 * @source https://github.com/pipipear/BD/tree/main/Plugins/MCPlayers
 * @updateUrl https://raw.githubusercontent.com/pipipear/BD/main/Plugins/MCPlayers/MCPlayers.plugin.js
 */


 class MCPlayers {
  log(m) {
    console.log(
      `%c[%cMCPlayers%c] %c${m}`,
      'font-weight: bold; color: #209127',
      'font-weight: bold; color: #55ed5e',
      'font-weight: bold; color: #209127', ''
    );
  }

  load() {
    if (window.mcp) {
      this.log('global reference already exists');
    } else {
      window.mcp = {
        README: "this key-value array holds important information, it was automatically generated by the MCPlayers plugin",
        update: false,
        pvf: (v) => { for (var r = ("" + v).replace("_", ".").replace(/[^0-9.]/g, "").split("."), o = 0, l = 0; l < r.length; ++l) o += Number(r[l]) / Math.pow(10, 3 * l); return o },
        iplist: {
          '923420827330957352': 'server_name',
          '744822941161619458': 'first_channel',
          '747152808616263772': 'first_channel'
        },
        cache: {},
        cloop: Date.now(),
        sever: '',
        log: this.log
      }
      this.log('created global reference');
    }
  }

  async listPlayers(ip, server) {
    // this.printPlayers(mcp.cache[ip], server);
    this.printPlayers(undefined, server);
    await this.fetchPlayers(ip, server);
  }

  async fetchPlayers(ip, server) {
    let res = await fetch(`https://api.minetools.eu/ping/${ip}/25565`);
    let json = await res.json();
    let players = json?.players?.sample?.map(e => e?.name)?.sort();
    if (players == undefined) players = null;
    mcp.cache[ip] = players;
    await this.printPlayers(players, server)
  }

  async printPlayers(players, server) {
    if (mcp.server != server) return;
    let cont = document.createElement('div');
    cont.id = 'mcPlayers';

    document.querySelector('#mcPlayers')?.remove();
    document.querySelector('div[class^="sidebar"]>nav>div[class^="container"]').prepend(cont);

    players?.forEach(p => {
      let h1 = document.createElement('h1');
      h1.textContent = p;
      cont.appendChild(h1);
    });

    var info = '';
    if (typeof(players) == 'object' && players?.length == 0) {
      info = 'No players online';
    } else if (players === null) {
      info = 'Server offline';
    }

    if (info) {
      let h1 = document.createElement('h1');
      h1.textContent = info;
      cont.appendChild(h1);
    }
  }

  async onSwitch(redraw, noloop) {
    let tsnow = Date.now();
    let server = window.location.pathname.split('/')[2];
    if (!noloop && mcp.server != server) mcp.cloop = tsnow;
    let mcsvip = mcp.iplist[server];
    switch (mcsvip) {
      case 'server_name':   mcsvip = document.querySelector('div[class^="sidebar"]>nav>div[class^="container"]>header>h1').textContent; break;
      case 'first_channel': mcsvip = document.querySelector('div[class^="sidebar"]>nav>div[class^="scroller"]>div>div[class^="containerDefault"][data-dnd-name]').dataset.dndName; break; 
    }

    if (mcsvip && server && (redraw || mcp.server != server || !document.querySelector('#mcPlayers'))) {
      this.log(`Fetching information for: ${mcsvip}`);
      mcp.server = server;
      this.listPlayers(mcsvip, server);
      if (!noloop) {
        await new Promise(r => setTimeout(r, 20000));
        while (mcp.cloop == tsnow) {
          if (!document.hidden) this.fetchPlayers(mcsvip, server);
          await new Promise(r => setTimeout(r, 20000));
          if (!document.hasFocus()) await new Promise(r => setTimeout(r, 20000));
        }
      }
    } else {
      mcp.server = server;
    }
  }

  async start() {
    fetch(BdApi.Plugins.get('MCPlayers').updateUrl).then(r => r.text()).then(f => {
      var remvrr = f.match(/\/\*\*\s*\n([^\*]|(\*(?!\/)))*\*\//)[0].match(/(?<=\* @version ).+/)[0];
      var remver = mcp.pvf(remvrr);
      var locvrr = BdApi.Plugins.get('MCPlayers').version;
      var locver = mcp.pvf(locvrr);
      if (remver > locver) {
        mcp.log(`updating ${locvrr} => ${remvrr}`);
        mcp.update = true;
        require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "MCPlayers.plugin.js"), f, (e) => e && (console.error(e), BdApi.alert('MCPlayers', 'failed to write plugin update to disk')));
      } else if (remver === locver) {
        mcp.log('no updates available');
      } else if (remver < locver) {
        mcp.log('plugin version is ahead');
      } else {
        mcp.log('plugin versions incomparable');
        BdApi.alert('MCPlayers', 'there was an issue checking the plugin version');
      }
    }).catch(e => (console.error(e), BdApi.alert('MCPlayers', 'failed to check for updates')));

    BdApi.injectCSS('MCPlayers-CSS', `
      html.app-focused #mcPlayers {
        opacity: 100%;
      }

      #mcPlayers {
        padding: 16px 16px 0px;
        color: var(--header-secondary);
        opacity: 92%;
        font-family: monospace;
        line-height: 1.1;
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
        transition: color .1s linear;
      }

      #mcPlayers > h1 {
        text-overflow: ellipsis;
        white-space: nowrap;
        overflow: hidden;
      }

      #mcPlayers:empty::after {
        content: "Loading...";
      }

      #mcPlayers + header {
        background-color: unset;
      }
    `);

    this.log('MCPlayers enabled');
    this.onSwitch(true);
    if (document.timeline.currentTime < 15000) {
      for (let i = 0; i < 20; i++) {
        await new Promise(r => setTimeout(r, 500));
        this.onSwitch(false, i == 19);
      }
    }
  }

  stop() {
    BdApi.clearCSS('MCPlayers-CSS');
    document.querySelector('#mcPlayers')?.remove();
    if (mcp?.server) mcp.server = '';
    if (mcp?.update) {
      delete window.mcp;
      this.log('removed global reference');
    }
    this.log('MCPlayers disabled');
  }
}
